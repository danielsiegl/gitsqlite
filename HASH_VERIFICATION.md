# Hash Verification Feature

## Overview

gitsqlite now includes automatic hash verification to ensure SQL files have not been manually modified between the `clean` (binary → SQL) and `smudge` (SQL → binary) operations. This prevents corruption and data integrity issues that could occur if someone edits the SQL text files directly in an editor.

**Operations with hash verification:**
- ✅ `clean` - Generates hash and appends to SQL output
- ✅ `smudge` - Verifies hash before restoring to binary
- ❌ `diff` - No hash (diff output is for display/comparison only)

## How It Works

### During Clean Operation (Binary → SQL)

When gitsqlite converts a binary SQLite database to SQL format:

1. The SQL content is streamed to the output
2. A SHA-256 hash is computed on-the-fly as the SQL is written
3. After all SQL content is written, a hash comment is appended as the last line:
   ```sql
   -- gitsqlite-hash: sha256:a1b2c3d4e5f6...
   ```

This happens for:
- Main data output (stdout)
- Schema files (when using `-schema` or `-schema-file` flags)

**Note:** The `diff` command does **not** include hash verification since it's only used for viewing/comparing, not for round-tripping back to binary.

### During Smudge Operation (SQL → Binary)

When gitsqlite converts SQL format back to binary SQLite:

1. The entire SQL input is read
2. The last line is checked for the hash comment
3. The hash is extracted and the content (without hash line) is hashed
4. If the computed hash matches the stored hash, the content is verified
5. The SQL (without hash line) is restored to binary SQLite
6. **If verification fails, the operation is aborted with an error**

This verification happens for:
- Main data input (stdin)
- Schema files (when using `-schema` or `-schema-file` flags)

## Benefits

### 1. Prevents Manual Editing

The hash ensures that SQL files generated by gitsqlite are not manually edited in an editor, which could lead to:
- Syntax errors that break smudge operations
- Data corruption
- Loss of binary database integrity
- Inconsistent data types or constraints

### 2. Detects File Corruption

If a SQL file is corrupted during:
- File system operations
- Git operations
- File transfers
- Storage issues

The hash will catch the corruption before it's restored to binary format.

### 3. Security

The hash provides assurance that the SQL content has not been tampered with, intentionally or accidentally.

## Hash Format

The hash line is always the last line of the SQL file and follows this format:

```
-- gitsqlite-hash: sha256:<64-character-hex-digest>
```

Example:
```sql
PRAGMA foreign_keys=OFF;
BEGIN TRANSACTION;
CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
INSERT INTO users VALUES(1,'Alice');
INSERT INTO users VALUES(2,'Bob');
COMMIT;
-- gitsqlite-hash: sha256:a7f3e8c2d1b6904523f1e0c8a9d4b5c6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2
```

## Error Messages

### Missing Hash

If a SQL file is missing the hash comment:
```
data hash verification failed: missing gitsqlite hash signature (expected last line to start with '-- gitsqlite-hash: sha256:')
```

### Hash Mismatch

If the SQL content has been modified:
```
data hash verification failed: hash verification failed: expected a7f3e8c2d1..., got b8e4f9d3e2... (file may have been modified)
```

### Schema File Hash Errors

Similar errors for schema files:
```
schema hash verification failed: hash verification failed: expected a7f3e8c2d1..., got b8e4f9d3e2... (file may have been modified)
```

## Technical Details

### Hash Algorithm

- **Algorithm**: SHA-256
- **Encoding**: Lowercase hexadecimal (64 characters)
- **Input**: All SQL content excluding the hash line itself

### Implementation

The hash verification is implemented in the `internal/hash` package:

- `HashWriter`: An `io.Writer` wrapper that computes SHA-256 hash while writing
- `VerifyAndStripHash()`: Reads content, verifies hash, and returns content without hash line

Key files:
- `/workdir/internal/hash/hash.go` - Core hash implementation
- `/workdir/internal/hash/hash_test.go` - Comprehensive unit tests
- `/workdir/internal/filters/clean.go` - Hash generation during clean
- `/workdir/internal/filters/smudge.go` - Hash verification during smudge
- `/workdir/internal/filters/diff.go` - **No hash** (diff is for viewing only, not round-tripping)

### Performance Impact

The hash verification adds minimal overhead:
- **Clean**: Hash is computed while streaming output (no extra pass)
- **Smudge**: Input must be fully read into memory for verification

For very large databases (100+ MB), the memory requirement during smudge may be noticeable, but this is necessary to ensure integrity.

## Testing

### Unit Tests

Comprehensive unit tests are provided in `/workdir/internal/hash/hash_test.go`:

```bash
go test ./internal/hash -v
```

Tests cover:
- Hash computation and determinism
- Round-trip verification (hash + verify)
- Detection of modified content
- Detection of wrong hash
- Detection of missing hash
- Edge cases (empty input, multiline content, etc.)

### Integration Testing

The existing smoketest validates the round-trip workflow:

```bash
# Linux/macOS
./scripts/smoketest.sh

# Windows (PowerShell)
.\scripts\smoketest.ps1
```

The smoketest will now verify that:
1. Clean operation adds hash
2. Smudge operation verifies and strips hash
3. Round-trip produces identical output (with matching hashes)

### Manual Testing

To manually test hash verification:

```bash
# Create a test database
sqlite3 test.db <<EOF
CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT);
INSERT INTO users VALUES(1,'Alice');
INSERT INTO users VALUES(2,'Bob');
EOF

# Convert to SQL with hash
./gitsqlite clean < test.db > test.sql

# View the hash at the end
tail -1 test.sql

# Verify it works
./gitsqlite smudge < test.sql > test2.db

# Test hash verification failure - edit the SQL file
sed -i "s/Alice/Charlie/" test.sql

# This should fail with hash verification error
./gitsqlite smudge < test.sql > test3.db
```

## Compatibility

### Backward Compatibility

⚠️ **Breaking Change**: SQL files generated by older versions of gitsqlite (without hash) will **not** be compatible with the new version.

To migrate existing repositories:
1. Check out the repository with the old version of gitsqlite
2. Let Git smudge all `.db` files to binary
3. Upgrade to the new version with hash verification
4. Re-run clean operation to regenerate SQL with hashes:
   ```bash
   git add -f *.db
   git commit -m "Regenerate SQLite dumps with hash verification"
   ```

### Future Versions

The hash format is designed to be extensible. If a different hash algorithm is needed in the future, the prefix format allows for versioning:
- Current: `-- gitsqlite-hash: sha256:...`
- Future: `-- gitsqlite-hash: sha512:...` or `-- gitsqlite-hash-v2: ...`

## Disabling Hash Verification (Not Recommended)

Hash verification cannot be disabled in this implementation, as it's a critical security and integrity feature. If you need to manually edit SQL files:

1. Convert to binary first: `./gitsqlite smudge < file.sql > file.db`
2. Edit the binary database using SQLite tools: `sqlite3 file.db`
3. Convert back to SQL: `./gitsqlite clean < file.db > file.sql`

This ensures proper hash generation and integrity.

## FAQ

**Q: What if I want to manually edit the SQL?**
A: Don't edit the SQL files directly. Instead, use SQLite tools to edit the binary database, then re-run clean to regenerate the SQL with a valid hash.

**Q: Can I merge SQL files manually?**
A: Merging SQL files manually is risky (see README caveats). If you must merge, after merging you'll need to restore to binary, then clean again to generate a valid hash.

**Q: Does the hash slow down operations?**
A: The performance impact is minimal - hash computation happens while streaming data. Only the smudge operation needs to read the full content into memory.

**Q: What if I'm using schema/data separation?**
A: Both the schema file and data file will have their own independent hashes. Both must verify successfully during smudge.

**Q: Can I verify a hash manually?**
A: Yes, you can use standard tools:
```bash
# Extract content without hash line
head -n -1 file.sql | sha256sum

# Compare with hash in last line
tail -1 file.sql
```

## Security Considerations

- **SHA-256** is cryptographically secure and collision-resistant
- Hash verification prevents **accidental** modifications, not malicious attacks
- An attacker with access to modify files could also update the hash
- For true tamper-evidence, use Git's commit signing (GPG) in addition to gitsqlite hash verification
